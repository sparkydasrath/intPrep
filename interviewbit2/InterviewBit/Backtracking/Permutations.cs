using System;
using System.Collections.Generic;
using System.Text;

namespace Backtracking
{
    public class Permutations
    {
        /*
            Following Tushar's https://www.youtube.com/watch?v=nYFd7VHKyWQ&feature=youtu.be guide

            Permutation with repeated characters but the output is unique (does not repeat permutations generated by the repeated chars)

            Algorithm:
            1. For input string, create a count array
                ex: aabc

                char   count
            --------------------
                a       2
                b       1
                c       1
            2. Create result array which is the input string's length
            3. Go from left to right and look for the first available char
                3a. A char is available if it's count > 0
            4. Put that char in the corresponding position in the result array
                NOTE: The position/index into the array is determined by the depth of the recursion
            5. Decrement the count (since we used it for the current step) and recurse
            6. When you return from the recursion, you restore the count and
                and then look for the next available character that has count > 0
         */

        private readonly Dictionary<char, int> map;
        private Tuple<char[], int[]> charCountPair;
        private char[] result;

        public Permutations()
        {
            map = new Dictionary<char, int>();
            AllResults = new List<string>();
        }

        public List<string> AllResults { get; }

        public void PermuteWithRepeatedCharsBase(string input)
        {
            // assume that s is already sorted so we are getting aabc

            // create count array
            foreach (char c in input)
            {
                if (!map.ContainsKey(c))
                    map[c] = 1;
                else map[c] += 1;
            }

            // create two arrays representing the above mapping of char to count
            charCountPair = GetCharAndCountArrayFromMap(map);

            // create result array
            result = new char[input.Length];

            PermuteWithRepeatedCharsDfs(charCountPair.Item1, charCountPair.Item2, result, 0);
        }

        private Tuple<char[], int[]> GetCharAndCountArrayFromMap(Dictionary<char, int> dict)
        {
            // create two arrays representing the above mapping of char to count
            char[] str = new char[dict.Count];
            int[] counts = new int[dict.Count];
            int index = 0;
            foreach (KeyValuePair<char, int> kvp in dict)
            {
                str[index] = kvp.Key;
                counts[index] = kvp.Value;
                index++;
            }

            return new Tuple<char[], int[]>(str, counts);
        }

        private void PermuteWithRepeatedCharsDfs(char[] input, int[] counts, char[] output, int depth)
        {
            // base case
            if (depth == output.Length)
            {
                // print out whatever is in the result array
                PrintArray(output);
                return;
            }
            for (int i = 0; i < input.Length; i++)
            {
                // 3. Go from left to right and look for the first available char 3a. A char is
                // available if it's count > 0
                if (counts[i] == 0) continue;

                // 4. Put that char in the corresponding position in the result array
                // NOTE: The position/ index into the array is determined by the depth of the recursion
                result[depth] = input[i];

                // 5. Decrement the count (since we used it for the current step) and recurse
                counts[i]--;

                PermuteWithRepeatedCharsDfs(input, counts, result, depth + 1);

                // 6.When you return from the recursion, you restore the count and and then look for
                // the next available character that has count > 0
                counts[i]++;
            }
        }

        private void PrintArray(char[] res)
        {
            StringBuilder sb = new StringBuilder();
            foreach (char c in res)
                sb.Append(c);
            AllResults.Add(sb.ToString());
        }
    }
}