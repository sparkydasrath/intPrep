using System;
using System.Collections.Generic;
using System.Text;

namespace Backtracking
{
    public class Permutations
    {
        /*
         *  Following Tushar's https://www.youtube.com/watch?v=nYFd7VHKyWQ&feature=youtu.be guide
         *
         *  Permutation with repeated characters but the output is unique (does not repeat permutations generated by the repeated chars)
         *
         *  Algorithm:
         *  1. For input string, create a count array
         *      ex: aabc
         *
         *      char   count
         * ---------------------
         *      a       2
         *      b       1
         *      c       1
         *  2. Create result array which is the input string's length
         *  3. Go from left to right and look for the first available char
         *      3a. A char is available if it's count > 0
         *  4. Put that char in the corresponding position in the result array
         *      NOTE: The position/index into the array is determined by the depth of the recursion
         *  5. Decrement the count (since we used it for the current step) and recurse
         *  6. When you return from the recursion, you restore the count and
         *      and then look for the next available character that has count > 0
         */

        public void PermuteWithRepeatedCharsBase(string input)
        {
            // assume that s is already sorted so we are getting aabc

            // create count array
            Dictionary<char, int> map = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (!map.ContainsKey(c))
                    map[c] = 1;
                else map[c] += 1;
            }

            // create two arrays representing the above mapping of char to count
            Tuple<char[], int[]> charCountPair = GetCharAndCountArrayFromMap(map);

            // create result array
            char[] result = new char[input.Length];

            PermuteWithRepeatedCharsDfs(charCountPair.Item1, charCountPair.Item2, result, 0);
        }

        public void PermuteWithRepeatedCharsDfs(char[] str, int[] counts, char[] result, int depth)
        {
            // base case
            if (depth == result.Length)
            {
                // print out whatever is in the result array
                PrintArray(result);
                return;
            }
            for (int i = 0; i < str.Length; i++)
            {
                // 3. Go from left to right and look for the first available char 3a. A char is
                // available if it's count > 0
                if (counts[i] == 0) continue;

                // 4. Put that char in the corresponding position in the result array
                // NOTE: The position/ index into the array is determined by the depth of the recursion
                result[depth] = str[i];

                // 5. Decrement the count (since we used it for the current step) and recurse
                counts[i]--;

                PermuteWithRepeatedCharsDfs(str, counts, result, depth + 1);

                // 6.When you return from the recursion, you restore the count and and then look for
                // the next available character that has count > 0
                counts[i]++;
            }
        }

        private Tuple<char[], int[]> GetCharAndCountArrayFromMap(Dictionary<char, int> map)
        {
            // create two arrays representing the above mapping of char to count
            char[] str = new char[map.Count];
            int[] counts = new int[map.Count];
            int index = 0;
            foreach (KeyValuePair<char, int> kvp in map)
            {
                str[index] = kvp.Key;
                counts[index] = kvp.Value;
                index++;
            }

            return new Tuple<char[], int[]>(str, counts);
        }

        private void PrintArray(char[] result)
        {
            StringBuilder sb = new StringBuilder();
            foreach (char c in result)
            {
                sb.Append(c);
            }

            Console.WriteLine(sb.ToString());
        }
    }
}